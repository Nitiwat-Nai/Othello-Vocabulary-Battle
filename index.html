<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Word Reversi - Nature Theme</title>

    <style>
        /* === 1. RESET & GLOBAL STYLES (THEME UPDATE) === */
        :root {
            /* ‡∏ò‡∏µ‡∏°‡∏™‡∏µ‡πÉ‡∏´‡∏°‡πà: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß ‡∏Ç‡∏≤‡∏ß ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏• ‡∏î‡∏≥ */
            --bg-color: #f4f7f0;       /* ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏Ç‡∏≤‡∏ß‡∏≠‡∏°‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏≠‡πà‡∏≠‡∏ô‡πÜ */
            --header-bg: #2e7d32;      /* ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥ */
            --board-container: #e8f5e9;/* ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏£‡∏≠‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏à‡∏≤‡∏á‡πÜ */
            --wood-border: #5d4037;    /* ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡πÄ‡∏Ç‡πâ‡∏° (‡∏Ç‡∏≠‡∏ö‡πÑ‡∏°‡πâ) */
            --btn-brown: #795548;      /* ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏• */
            --btn-green: #43a047;      /* ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß */
            --text-color: #1b1b1b;     /* ‡∏™‡∏µ‡∏î‡∏≥ */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
        }

        body {
            font-family: 'Sarabun', 'Segoe UI', Tahoma, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
        }

        #app-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--bg-color);
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        /* === 2. HEADER & BACK BUTTON === */
        header {
            flex-shrink: 0;
            width: 100%;
            height: 60px;
            background: var(--header-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏ö‡∏ö Absolute */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 20;
        }

        h1 {
            color: #fff;
            font-size: 1.5em;
            font-weight: 800;
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        /* ‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å (‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô) */
        #back-home-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            
            background-color: #fff;
            color: var(--header-bg);
            border: 2px solid #fff;
            border-radius: 20px;
            
            padding: 6px 12px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        #back-home-btn:active {
            transform: translateY(-50%) scale(0.95);
            background-color: #f1f1f1;
        }

        .hidden { display: none !important; }

        /* === 3. MENU (MOVED TO TOP) === */
        #main-menu {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* ‡∏î‡∏±‡∏ô‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô */
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            padding: 30px 20px; /* ‡πÄ‡∏û‡∏¥‡πà‡∏° padding ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô */
        }

        .menu-btn {
            width: 100%;
            padding: 15px;
            /* ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏ó‡∏ô‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß-‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏• */
            background: linear-gradient(135deg, var(--btn-green) 0%, #2e7d32 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        .menu-btn:active { transform: scale(0.98); }
        
        /* ‡πÄ‡∏™‡πâ‡∏ô‡∏Ñ‡∏±‡πà‡∏ô */
        hr {
            border: 0;
            border-top: 2px dashed #ccc;
            width: 100%;
            margin: 10px 0;
        }
        
        /* ‡∏õ‡∏∏‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î Classic ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á */
        .btn-classic {
            background: linear-gradient(135deg, #8d6e63 0%, var(--wood-border) 100%);
        }

        /* === 4. GAME SCREEN LAYOUT === */
        #game-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            width: 100%;
            align-items: center;
            padding: 10px;
        }

        #score-board {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            padding: 10px;
            background: white;
            border-radius: 10px;
            font-weight: 800;
            color: var(--text-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border: 1px solid #ddd;
        }

        #status-message {
            background: var(--btn-brown);
            color: white;
            padding: 5px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.95em;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* === 5. GAME BOARD CONTAINER === */
        #game-board-container {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--board-container);
            border-radius: 12px;
            padding: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        /* === 6. THE BOARD (THINNER BORDER & NO SHADOW) === */
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            
            width: min(90vw, 55vh);
            height: min(90vw, 55vh);
            aspect-ratio: 1 / 1;

            background-color: #1b5e20; /* ‡∏û‡∏∑‡πâ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÄ‡∏Ç‡πâ‡∏° */
            
            /* --- UPDATED: ‡∏Ç‡∏≠‡∏ö‡∏ö‡∏≤‡∏á‡∏•‡∏á + ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏á‡∏≤ --- */
            border: 6px solid var(--wood-border); 
            border-radius: 4px; 
            box-shadow: none; /* ‡πÄ‡∏≠‡∏≤‡πÄ‡∏á‡∏≤‡∏≠‡∏≠‡∏Å */
            /* ---------------------------------- */
        }

        .cell {
            background-color: #4caf50; /* ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô */
            position: relative;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        
        /* ‡∏•‡∏≤‡∏¢‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö */
        .cell:nth-child(odd) { background-color: #43a047; } 

        .cell.hint::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 25%; height: 25%;
            background: rgba(0,0,0,0.2); /* ‡∏à‡∏∏‡∏î‡∏î‡∏≥‡∏à‡∏≤‡∏á‡πÜ ‡πÅ‡∏ö‡∏ö‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á */
            border-radius: 50%;
        }

        /* === 7. DISCS === */
        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            position: absolute;
            top: 7.5%; left: 7.5%;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3); /* ‡πÄ‡∏á‡∏≤‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ö‡∏≤‡∏á‡πÜ */
            transition: transform 0.3s;
            backface-visibility: hidden;
        }
        
        .disc.black { background: #111; }
        .disc.white { background: #fff; }

        .disc.flipped {
            animation: flipAnim 0.4s forwards;
        }

        @keyframes flipAnim {
            0% { transform: scale(1) rotateY(0deg); }
            50% { transform: scale(1.1) rotateY(90deg); }
            100% { transform: scale(1) rotateY(180deg); }
        }

        /* === 8. QUIZ OVERLAY === */
        #question-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            padding: 20px;
        }
        
        #question-box {
            background: white;
            padding: 25px;
            border-radius: 15px;
            width: 100%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .quiz-correct { border: 3px solid #4caf50; background: #e8f5e9 !important; }
        .quiz-error { border: 3px solid #f44336; background: #ffebee !important; }

        #options-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .option-btn {
            flex: 1;
            padding: 15px;
            background: var(--header-bg);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
        }

    </style>
</head>

<body>
    <div id="app-container">
        <header>
            <h1>Word Reversi</h1>
            <button id="back-home-btn" class="hidden" onclick="returnToMenu()">‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</button>
        </header>

        <main id="main-menu">
            <button class="menu-btn" onclick="startGame(true, true)">üß† vs Robot (Quiz)</button>
            <button class="menu-btn" onclick="startGame(false, true)">üßë‚Äçü§ù‚Äçüßë 2-Player (Quiz)</button>
            
            <hr>

            <button class="menu-btn btn-classic" onclick="startGame(true, false)">ü§ñ vs Robot (Classic)</button>
            <button class="menu-btn btn-classic" onclick="startGame(false, false)">üßë‚Äçü§ù‚Äçüßë 2-Player (Classic)</button>
        </main>

        <main id="game-screen" class="hidden">
            <div id="score-board">
                <span id="score-black">‚ö´ 2</span>
                <span id="score-white">‚ö™ 2</span>
            </div>
            
            <div id="status-message">Ready</div>

            <div id="game-board-container">
                <div id="game-board"></div>
            </div>

            <div id="question-overlay" class="hidden">
                <div id="question-box">
                    <h3 style="color:#2e7d32; margin-bottom:15px; font-size:1.3em;">Vocabulary</h3>
                    <p id="question-text" style="font-size:1.1em; margin-bottom:20px; color:#333; font-weight:500;"></p>
                    <div id="options-container"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // === CONFIG ===
        const BOARD_SIZE = 8;
        let board = [];
        let currentPlayer = 1; // 1=Black, 2=White
        let lastClickedCell = null;
        let isRobotMode = false;
        let isQuizMode = true;
        let isProcessing = false;
        let availableQuizIndices = [];

        // === AUDIO ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'correct') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'flip') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            }
        }

        // === VOCABULARY ===
        const vocabularyList = [
            { question: "Opposite of 'Big'?", options: { A: "Small", B: "Huge" }, correct: "A" },
            { question: "Synonym for 'Start'?", options: { A: "End", B: "Begin" }, correct: "B" },
            { question: "'Run' means...", options: { A: "Move fast", B: "Sleep" }, correct: "A" },
            { question: "Opposite of 'Hot'?", options: { A: "Cold", B: "Warm" }, correct: "A" },
            { question: "Synonym for 'Quick'?", options: { A: "Slow", B: "Fast" }, correct: "B" },
            { question: "Opposite of 'Day'?", options: { A: "Night", B: "Noon" }, correct: "A" },
            { question: "Opposite of 'Rich'?", options: { A: "Poor", B: "Wealthy" }, correct: "A" },
            { question: "Synonym for 'Happy'?", options: { A: "Sad", B: "Joyful" }, correct: "B" },
            { question: "Opposite of 'Up'?", options: { A: "Down", B: "Left" }, correct: "A" },
            { question: "Does a dog bark?", options: { A: "Yes", B: "No" }, correct: "A" }
        ];
        let currentQuestion = null;

        // === DOM ===
        const els = {
            menu: document.getElementById('main-menu'),
            game: document.getElementById('game-screen'),
            board: document.getElementById('game-board'),
            status: document.getElementById('status-message'),
            overlay: document.getElementById('question-overlay'),
            qBox: document.getElementById('question-box'),
            qText: document.getElementById('question-text'),
            opts: document.getElementById('options-container'),
            scoreB: document.getElementById('score-black'),
            scoreW: document.getElementById('score-white'),
            backBtn: document.getElementById('back-home-btn')
        };

        const DIRECTIONS = [
            {r:-1,c:0}, {r:1,c:0}, {r:0,c:-1}, {r:0,c:1},
            {r:-1,c:-1}, {r:-1,c:1}, {r:1,c:-1}, {r:1,c:1}
        ];

        // === GAME LOGIC ===
        function startGame(robot, quiz) {
            isRobotMode = robot;
            isQuizMode = quiz;
            isProcessing = false;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            els.menu.classList.add('hidden');
            els.game.classList.remove('hidden');
            els.backBtn.classList.remove('hidden'); // Show Back Button
            
            if(isQuizMode) availableQuizIndices = Array.from({length: vocabularyList.length}, (_, i) => i);
            initBoard();
        }

        function returnToMenu() {
            els.menu.classList.remove('hidden');
            els.game.classList.add('hidden');
            els.backBtn.classList.add('hidden'); // Hide Back Button in Menu
        }

        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            els.board.innerHTML = '';
            
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.onclick = handleCellClick;
                    els.board.appendChild(cell);
                }
            }
            board[3][3] = 2; board[3][4] = 1;
            board[4][3] = 1; board[4][4] = 2;
            
            currentPlayer = 1;
            updateVisuals();
            updateStatus();
        }

        function getFlips(r, c, player) {
            if (board[r][c] !== 0) return [];
            const opponent = player === 1 ? 2 : 1;
            const flips = [];

            for (const d of DIRECTIONS) {
                let nr = r + d.r, nc = c + d.c;
                const path = [];
                while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === opponent) {
                    path.push({r: nr, c: nc});
                    nr += d.r; nc += d.c;
                }
                if (path.length > 0 && nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                    flips.push(...path);
                }
            }
            return flips;
        }

        function isValid(r, c, player) {
            return getFlips(r, c, player).length > 0;
        }

        function updateVisuals() {
            let b=0, w=0;
            const validMoves = getAllMoves(currentPlayer);
            const showHints = !isProcessing && !(isRobotMode && currentPlayer === 2);

            Array.from(els.board.children).forEach(cell => {
                const r = parseInt(cell.dataset.r);
                const c = parseInt(cell.dataset.c);
                const val = board[r][c];
                
                cell.className = 'cell';
                cell.innerHTML = '';

                if (val !== 0) {
                    const disc = document.createElement('div');
                    disc.className = `disc ${val === 1 ? 'black' : 'white'}`;
                    cell.appendChild(disc);
                    val === 1 ? b++ : w++;
                } else if (showHints && validMoves.some(m => m.r === r && m.c === c)) {
                    cell.classList.add('hint');
                }
            });
            els.scoreB.innerText = `‚ö´ ${b}`;
            els.scoreW.innerText = `‚ö™ ${w}`;
        }

        function getAllMoves(player) {
            const moves = [];
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (getFlips(r, c, player).length > 0) moves.push({r, c});
                }
            }
            return moves;
        }

        function updateStatus() {
            const pName = currentPlayer === 1 ? 'Black' : 'White';
            const moves = getAllMoves(currentPlayer);

            if (moves.length === 0) {
                const oppMoves = getAllMoves(currentPlayer === 1 ? 2 : 1);
                if (oppMoves.length === 0) {
                    const b = parseInt(els.scoreB.innerText.split(' ')[1]);
                    const w = parseInt(els.scoreW.innerText.split(' ')[1]);
                    const msg = b > w ? 'Black Wins!' : w > b ? 'White Wins!' : 'Draw!';
                    els.status.innerHTML = `üèÜ ${msg}`;
                } else {
                    els.status.innerText = `üö´ ${pName} Pass!`;
                    setTimeout(() => {
                        currentPlayer = currentPlayer === 1 ? 2 : 1;
                        updateStatus();
                    }, 1500);
                }
                return;
            }

            els.status.innerText = `${pName}'s Turn`;
            updateVisuals();

            if (isRobotMode && currentPlayer === 2) {
                setTimeout(botMove, 1000);
            }
        }

        function handleCellClick(e) {
            if (isProcessing || !els.overlay.classList.contains('hidden')) return;
            if (isRobotMode && currentPlayer === 2) return;

            const r = parseInt(e.currentTarget.dataset.r);
            const c = parseInt(e.currentTarget.dataset.c);

            if (!isValid(r, c, currentPlayer)) return;

            lastClickedCell = {r, c};

            if (isQuizMode) {
                startQuiz();
            } else {
                executeMove(true);
            }
        }

        function startQuiz() {
            if (availableQuizIndices.length === 0) availableQuizIndices = Array.from({length: vocabularyList.length}, (_, i) => i);
            const rand = Math.floor(Math.random() * availableQuizIndices.length);
            const idx = availableQuizIndices[rand];
            availableQuizIndices.splice(rand, 1);
            
            currentQuestion = vocabularyList[idx];
            els.qBox.className = '';
            els.qText.innerText = currentQuestion.question;
            els.opts.innerHTML = '';
            
            Object.keys(currentQuestion.options).forEach(k => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.innerText = currentQuestion.options[k];
                btn.onclick = () => handleAnswer(k);
                els.opts.appendChild(btn);
            });
            els.overlay.classList.remove('hidden');
        }

        function handleAnswer(ans) {
            const correct = (ans === currentQuestion.correct);
            if (correct) {
                els.qBox.classList.add('quiz-correct');
                playSound('correct');
            } else {
                els.qBox.classList.add('quiz-error');
                playSound('error');
            }
            
            setTimeout(() => {
                els.overlay.classList.add('hidden');
                executeMove(correct);
            }, 800);
        }

        function botMove() {
            const moves = getAllMoves(currentPlayer);
            if (moves.length > 0) {
                const m = moves[Math.floor(Math.random() * moves.length)];
                lastClickedCell = m;
                executeMove(true);
            }
        }

        async function executeMove(shouldFlip) {
            isProcessing = true;
            const {r, c} = lastClickedCell;
            const opponent = currentPlayer === 1 ? 2 : 1;
            
            const flips = shouldFlip ? getFlips(r, c, currentPlayer) : [];
            
            board[r][c] = currentPlayer;
            updateVisuals();

            if (flips.length > 0) {
                for (const f of flips) {
                    await new Promise(r => setTimeout(r, 200));
                    const idx = f.r * BOARD_SIZE + f.c;
                    const cell = els.board.children[idx];
                    const disc = cell.querySelector('.disc');
                    if (disc) {
                        disc.classList.add('flipped');
                        playSound('flip');
                        setTimeout(() => {
                            board[f.r][f.c] = currentPlayer;
                            disc.classList.remove('black', 'white');
                            disc.classList.add(currentPlayer === 1 ? 'black' : 'white');
                        }, 200);
                    }
                }
                await new Promise(r => setTimeout(r, 300));
                flips.forEach(f => board[f.r][f.c] = currentPlayer);
                updateVisuals();
            }

            isProcessing = false;
            currentPlayer = opponent;
            updateStatus();
        }
    </script>
</body>
</html>
