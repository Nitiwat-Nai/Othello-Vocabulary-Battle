<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>‚ú® Word Reversi - Perfect Fix</title>

    <style>
        /* === 1. RESET & GLOBAL STYLES === */
        :root {
            --bg-color: #f7e6ff;
            --board-bg: #c7f0d0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #app-container {
            width: 100%;
            height: 100%;
            /* ‡πÉ‡∏ä‡πâ Flexbox ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á */
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.5);
            padding: 10px;
            /* ‡πÄ‡∏ß‡πâ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≠‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ï‡∏¥‡πà‡∏á/‡∏Ç‡∏≠‡∏ö‡∏°‡∏ô */
            padding-top: max(10px, env(safe-area-inset-top));
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        /* === 2. HEADER === */
        header {
            text-align: center;
            flex-shrink: 0;
            margin-bottom: 5px;
        }

        h1 {
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: clamp(1.5em, 5vw, 2em);
            font-weight: 900;
            margin: 0;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
        }

        .hidden { display: none !important; }

        /* === 3. MENU === */
        #main-menu {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        .menu-btn {
            padding: 18px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .menu-btn:active { transform: scale(0.96); }

        /* === 4. GAME SCREEN LAYOUT === */
        #game-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            width: 100%;
            align-items: center; /* ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô */
        }

        #score-board {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 500px;
            padding: 10px;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 12px;
            font-weight: 800;
            color: #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #status-message {
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            color: #4b0082;
            font-weight: bold;
            font-size: 0.9em;
            text-align: center;
        }

        /* === 5. GAME BOARD CONTAINER === */
        #game-board-container {
            flex: 1; /* ‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center; /* ‡∏à‡∏±‡∏î‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠ */
            background-color: var(--board-bg);
            border-radius: 16px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            padding: 10px;
            overflow: hidden;
        }

        /* === 6. THE BOARD (Fixed Size Logic) === */
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            
            /* --- ‡∏™‡∏π‡∏ï‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô --- */
            /* ‡πÉ‡∏´‡πâ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÄ‡∏ó‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡πÑ‡∏î‡πâ (95vw) ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 55vh ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ UI */
            /* ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ aspect-ratio ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏±‡∏ï‡∏∏‡∏£‡∏±‡∏™ */
            width: min(95vw, 60vh);
            height: min(95vw, 60vh); /* Fallback for old browsers */
            aspect-ratio: 1 / 1;
            /* ------------------------- */

            background-color: #1a5c3a;
            border-radius: 8px;
            padding: 2px; /* Border padding */
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .cell {
            background-color: #3cb371; /* ‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô */
            background-image: linear-gradient(135deg, #3cb371 0%, #2e8b57 100%);
            position: relative;
            cursor: pointer;
            /* ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Cell ‡∏¢‡∏∑‡∏î‡πÄ‡∏ï‡πá‡∏° Grid Area */
            width: 100%;
            height: 100%;
        }

        /* ‡∏à‡∏∏‡∏î‡∏ö‡∏≠‡∏Å‡πÉ‡∏ö‡πâ (Hint) */
        .cell.hint::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 20%; height: 20%;
            background: rgba(255,255,255,0.4);
            border-radius: 50%;
        }

        /* === 7. DISCS === */
        .disc {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            position: absolute;
            top: 10%; left: 10%;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.4);
            transition: transform 0.3s;
            backface-visibility: hidden; /* ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á Animation */
        }
        
        .disc.black { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .disc.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }

        .disc.flipped {
            animation: flipAnim 0.4s forwards;
        }

        @keyframes flipAnim {
            0% { transform: scale(1) rotateY(0deg); }
            50% { transform: scale(1.2) rotateY(90deg); }
            100% { transform: scale(1) rotateY(180deg); }
        }

        /* === 8. QUIZ OVERLAY === */
        #question-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            padding: 20px;
        }
        
        #question-box {
            background: white;
            padding: 25px;
            border-radius: 15px;
            width: 100%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .quiz-correct { border: 3px solid #4caf50; background: #e8f5e9 !important; }
        .quiz-error { border: 3px solid #f44336; background: #ffebee !important; }

        #options-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .option-btn {
            flex: 1;
            padding: 12px;
            background: #6c5ce7;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
        }

    </style>
</head>

<body>
    <div id="app-container">
        <header>
            <h1>‚ú® Word Reversi ‚ú®</h1>
        </header>

        <main id="main-menu">
            <h2 style="text-align:center; color:#4b0082;">üéÆ Select Mode</h2>
            <button class="menu-btn" onclick="startGame(true, true)">üß† vs Robot (Quiz)</button>
            <button class="menu-btn" onclick="startGame(false, true)">üßë‚Äçü§ù‚Äçüßë 2-Player (Quiz)</button>
            <hr style="border-top:1px solid #ccc; width:80%; margin:0 auto;">
            <button class="menu-btn" onclick="startGame(true, false)">ü§ñ vs Robot (Classic)</button>
            <button class="menu-btn" onclick="startGame(false, false)">üßë‚Äçü§ù‚Äçüßë 2-Player (Classic)</button>
        </main>

        <main id="game-screen" class="hidden">
            <div id="score-board">
                <span id="score-black">‚ö´ 2</span>
                <span id="score-white">‚ö™ 2</span>
            </div>
            <div id="status-message">Ready</div>

            <div id="game-board-container">
                <div id="game-board"></div>
            </div>

            <div id="question-overlay" class="hidden">
                <div id="question-box">
                    <h3 style="color:#6c5ce7; margin-bottom:15px;">Vocabulary</h3>
                    <p id="question-text" style="font-size:1.1em; margin-bottom:20px; color:#333;"></p>
                    <div id="options-container"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // === CONFIG ===
        const BOARD_SIZE = 8;
        let board = [];
        let currentPlayer = 1; // 1=Black, 2=White
        let lastClickedCell = null;
        let isRobotMode = false;
        let isQuizMode = true;
        let isProcessing = false;
        let availableQuizIndices = [];

        // === AUDIO ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'correct') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'flip') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            }
        }

        // === VOCABULARY ===
        const vocabularyList = [
            { question: "Opposite of 'Big'?", options: { A: "Small", B: "Huge" }, correct: "A" },
            { question: "Synonym for 'Start'?", options: { A: "End", B: "Begin" }, correct: "B" },
            { question: "'Run' means...", options: { A: "Move fast", B: "Sleep" }, correct: "A" },
            { question: "Opposite of 'Hot'?", options: { A: "Cold", B: "Warm" }, correct: "A" },
            { question: "Synonym for 'Quick'?", options: { A: "Slow", B: "Fast" }, correct: "B" }
        ];
        let currentQuestion = null;

        // === DOM ===
        const els = {
            menu: document.getElementById('main-menu'),
            game: document.getElementById('game-screen'),
            board: document.getElementById('game-board'),
            status: document.getElementById('status-message'),
            overlay: document.getElementById('question-overlay'),
            qBox: document.getElementById('question-box'),
            qText: document.getElementById('question-text'),
            opts: document.getElementById('options-container'),
            scoreB: document.getElementById('score-black'),
            scoreW: document.getElementById('score-white')
        };

        const DIRECTIONS = [
            {r:-1,c:0}, {r:1,c:0}, {r:0,c:-1}, {r:0,c:1},
            {r:-1,c:-1}, {r:-1,c:1}, {r:1,c:-1}, {r:1,c:1}
        ];

        // === GAME LOGIC ===
        function startGame(robot, quiz) {
            isRobotMode = robot;
            isQuizMode = quiz;
            isProcessing = false;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            els.menu.classList.add('hidden');
            els.game.classList.remove('hidden');
            
            if(isQuizMode) availableQuizIndices = Array.from({length: vocabularyList.length}, (_, i) => i);
            initBoard();
        }

        function returnToMenu() {
            els.menu.classList.remove('hidden');
            els.game.classList.add('hidden');
        }

        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            els.board.innerHTML = '';
            
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.onclick = handleCellClick;
                    els.board.appendChild(cell);
                }
            }
            // Init discs
            board[3][3] = 2; board[3][4] = 1;
            board[4][3] = 1; board[4][4] = 2;
            
            currentPlayer = 1;
            updateVisuals();
            updateStatus();
        }

        function getFlips(r, c, player) {
            if (board[r][c] !== 0) return []; // ‡∏ä‡πà‡∏≠‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á
            const opponent = player === 1 ? 2 : 1;
            const flips = [];

            for (const d of DIRECTIONS) {
                let nr = r + d.r, nc = c + d.c;
                const path = [];
                // ‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏õ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏¢‡πÜ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡∏®‡∏±‡∏ï‡∏£‡∏π
                while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === opponent) {
                    path.push({r: nr, c: nc});
                    nr += d.r; nc += d.c;
                }
                // ‡∏ñ‡πâ‡∏≤‡∏à‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏û‡∏ß‡∏Å‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏Ñ‡∏±‡πà‡∏ô‡∏Å‡∏•‡∏≤‡∏á
                if (path.length > 0 && nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                    flips.push(...path);
                }
            }
            return flips;
        }

        function isValid(r, c, player) {
            return getFlips(r, c, player).length > 0;
        }

        function updateVisuals() {
            let b=0, w=0;
            const validMoves = getAllMoves(currentPlayer);
            const showHints = !isProcessing && !(isRobotMode && currentPlayer === 2);

            Array.from(els.board.children).forEach(cell => {
                const r = parseInt(cell.dataset.r);
                const c = parseInt(cell.dataset.c);
                const val = board[r][c];
                
                cell.className = 'cell';
                cell.innerHTML = '';

                if (val !== 0) {
                    const disc = document.createElement('div');
                    disc.className = `disc ${val === 1 ? 'black' : 'white'}`;
                    cell.appendChild(disc);
                    val === 1 ? b++ : w++;
                } else if (showHints && validMoves.some(m => m.r === r && m.c === c)) {
                    cell.classList.add('hint');
                }
            });
            els.scoreB.innerText = `‚ö´ ${b}`;
            els.scoreW.innerText = `‚ö™ ${w}`;
        }

        function getAllMoves(player) {
            const moves = [];
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (getFlips(r, c, player).length > 0) moves.push({r, c});
                }
            }
            return moves;
        }

        function updateStatus() {
            const pName = currentPlayer === 1 ? '‚ö´ Black' : '‚ö™ White';
            const moves = getAllMoves(currentPlayer);

            if (moves.length === 0) {
                const oppMoves = getAllMoves(currentPlayer === 1 ? 2 : 1);
                if (oppMoves.length === 0) {
                    // Game Over
                    const b = parseInt(els.scoreB.innerText.split(' ')[1]);
                    const w = parseInt(els.scoreW.innerText.split(' ')[1]);
                    const msg = b > w ? 'Black Wins!' : w > b ? 'White Wins!' : 'Draw!';
                    els.status.innerHTML = `üèÜ ${msg} <button onclick="returnToMenu()">Menu</button>`;
                } else {
                    // Pass Turn
                    els.status.innerText = `üö´ ${pName} Pass!`;
                    setTimeout(() => {
                        currentPlayer = currentPlayer === 1 ? 2 : 1;
                        updateStatus();
                    }, 1500);
                }
                return;
            }

            els.status.innerText = `${pName}'s Turn`;
            updateVisuals();

            if (isRobotMode && currentPlayer === 2) {
                setTimeout(botMove, 1000);
            }
        }

        function handleCellClick(e) {
            if (isProcessing || !els.overlay.classList.contains('hidden')) return;
            if (isRobotMode && currentPlayer === 2) return;

            const r = parseInt(e.currentTarget.dataset.r);
            const c = parseInt(e.currentTarget.dataset.c);

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á *‡∏Å‡πà‡∏≠‡∏ô* ‡∏ó‡∏≥‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏∑‡πà‡∏ô
            if (!isValid(r, c, currentPlayer)) return;

            lastClickedCell = {r, c};

            if (isQuizMode) {
                startQuiz();
            } else {
                executeMove(true);
            }
        }

        // === QUIZ ===
        function startQuiz() {
            if (availableQuizIndices.length === 0) availableQuizIndices = Array.from({length: vocabularyList.length}, (_, i) => i);
            const rand = Math.floor(Math.random() * availableQuizIndices.length);
            const idx = availableQuizIndices[rand];
            availableQuizIndices.splice(rand, 1);
            
            currentQuestion = vocabularyList[idx];
            els.qBox.className = '';
            els.qText.innerText = currentQuestion.question;
            els.opts.innerHTML = '';
            
            Object.keys(currentQuestion.options).forEach(k => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.innerText = currentQuestion.options[k];
                btn.onclick = () => handleAnswer(k);
                els.opts.appendChild(btn);
            });
            els.overlay.classList.remove('hidden');
        }

        function handleAnswer(ans) {
            const correct = (ans === currentQuestion.correct);
            if (correct) {
                els.qBox.classList.add('quiz-correct');
                playSound('correct');
            } else {
                els.qBox.classList.add('quiz-error');
                playSound('error');
            }
            
            setTimeout(() => {
                els.overlay.classList.add('hidden');
                executeMove(correct);
            }, 800);
        }

        // === MOVE EXECUTION ===
        function botMove() {
            const moves = getAllMoves(currentPlayer);
            if (moves.length > 0) {
                const m = moves[Math.floor(Math.random() * moves.length)];
                lastClickedCell = m;
                executeMove(true);
            }
        }

        async function executeMove(shouldFlip) {
            isProcessing = true;
            const {r, c} = lastClickedCell;
            const opponent = currentPlayer === 1 ? 2 : 1;
            
            // --- KEY FIX: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Flips ‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ ---
            // ‡∏ñ‡πâ‡∏≤‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏Å‡πà‡∏≠‡∏ô (board[r][c] = p) ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô getFlips ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ä‡πà‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞ return []
            const flips = shouldFlip ? getFlips(r, c, currentPlayer) : [];
            
            // ‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢
            board[r][c] = currentPlayer;
            updateVisuals();

            // Animation
            if (flips.length > 0) {
                for (const f of flips) {
                    await new Promise(r => setTimeout(r, 200));
                    const idx = f.r * BOARD_SIZE + f.c;
                    const cell = els.board.children[idx];
                    const disc = cell.querySelector('.disc');
                    if (disc) {
                        disc.classList.add('flipped');
                        playSound('flip');
                        // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å Animation ‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏ó‡∏≤‡∏á
                        setTimeout(() => {
                            board[f.r][f.c] = currentPlayer;
                            disc.classList.remove('black', 'white');
                            disc.classList.add(currentPlayer === 1 ? 'black' : 'white');
                        }, 200);
                    }
                }
                // ‡∏£‡∏≠‡πÉ‡∏´‡πâ Animation ‡∏à‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                await new Promise(r => setTimeout(r, 300));
                // Update Logic ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ß‡∏£‡πå
                flips.forEach(f => board[f.r][f.c] = currentPlayer);
                updateVisuals();
            }

            isProcessing = false;
            currentPlayer = opponent;
            updateStatus();
        }
    </script>
</body>
</html>
