<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>‚ú® Word Reversi Battle - Mobile Fullscreen</title>

    <style>
        /* === 1. RESET & GLOBAL STYLES === */
        :root {
            --bg-color: #f7e6ff;
            --board-bg: #c7f0d0;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏à */
            user-select: none; 
            -webkit-user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡πâ‡∏á (Rubber banding) ‡∏ö‡∏ô iOS */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            /* ‡πÉ‡∏ä‡πâ Dynamic Viewport Height ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ Address bar ‡∏ö‡∏±‡∏á */
            height: 100dvh; 
        }

        #app-container {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.5); /* ‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÉ‡∏™‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            
            /* ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iPhone ‡∏£‡∏∏‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà */
            padding-top: max(10px, var(--safe-top));
            padding-bottom: max(10px, var(--safe-bottom));
            padding-left: max(10px, var(--safe-left));
            padding-right: max(10px, var(--safe-right));
        }

        /* === 2. HEADER === */
        header {
            text-align: center;
            flex-shrink: 0;
            padding-bottom: 5px;
        }

        h1 {
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
            font-size: clamp(1.5em, 6vw, 2em);
            font-weight: 900;
            margin: 0;
            line-height: 1.2;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .hidden { display: none !important; }

        /* === 3. MAIN MENU === */
        #main-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            justify-content: center;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        #main-menu h2 {
            color: #4b0082;
            font-size: 1.5em;
            text-align: center;
            margin-bottom: 10px;
        }

        .menu-btn {
            padding: 20px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border: none;
            border-radius: 15px;
            font-size: 1.1em;
            font-weight: 700;
            color: white;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
            transition: transform 0.1s;
        }

        .menu-btn:active { transform: scale(0.96); }

        /* === 4. GAME SCREEN === */
        #game-screen {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            width: 100%;
            max-width: 600px; /* ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏ö‡∏ô iPad/Desktop */
            margin: 0 auto;
            overflow: hidden;
        }

        #score-board {
            display: flex;
            justify-content: space-around;
            font-size: 1.2em;
            font-weight: 800;
            color: #333;
            padding: 10px;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        #status-message {
            font-weight: 700;
            color: #4b0082;
            font-size: 0.95em;
            text-align: center;
            padding: 6px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            min-height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* === 5. GAME BOARD (FLEXIBLE) === */
        #game-board-container {
            background-color: var(--board-bg);
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            flex: 1; /* ‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            min-height: 0; /* ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Flex item ‡∏•‡πâ‡∏ô */
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            
            /* ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏î‡∏¢‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô 1:1 */
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1 / 1;
            
            background-color: #1a5c3a;
            border-radius: 8px;
            overflow: hidden;
            /* ‡πÄ‡∏û‡∏¥‡πà‡∏° touch-action ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∑‡πà‡∏ô‡πÑ‡∏´‡∏• */
            touch-action: none; 
        }

        .cell {
            background: linear-gradient(135deg, #3cb371 0%, #2e8b57 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .cell.hint {
            background: linear-gradient(135deg, #55c485 0%, #45b475 100%);
        }

        .cell.hint::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            animation: hintPulse 1.5s infinite;
        }

        @keyframes hintPulse {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }

        /* === 6. DISCS === */
        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            display: block;
            transition: transform 0.3s ease;
            transform-style: preserve-3d;
            position: relative;
        }
        
        /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏≤‡πÅ‡∏•‡∏∞‡∏°‡∏¥‡∏ï‡∏¥‡πÉ‡∏´‡πâ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ */
        .disc::before {
            content: "";
            position: absolute;
            top: 10%; left: 10%; width: 80%; height: 80%;
            border-radius: 50%;
            background: linear-gradient(145deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 50%);
        }

        .disc.black { background: #222; }
        .disc.white { background: #fff; }

        .disc.flipped { animation: flip-animation 0.5s forwards; }

        @keyframes flip-animation {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg) scale(1.2); }
            100% { transform: rotateY(180deg); }
        }

        /* === 7. OVERLAYS === */
        #question-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #question-box {
            background: #fff;
            padding: 25px;
            width: 90%;
            max-width: 350px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        #question-text {
            font-size: 1.1em;
            color: #333;
            margin: 15px 0 25px 0;
            line-height: 1.5;
        }

        .quiz-correct { border: 4px solid #4caf50; background: #e8f5e9 !important; }
        .quiz-error { border: 4px solid #f44336; background: #ffebee !important; }

        #options-container {
            display: flex;
            gap: 10px;
        }

        .option-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 12px;
            background: #6c5ce7;
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
        }
        
        .option-btn:active { transform: scale(0.95); }

    </style>
</head>

<body>
    <div id="app-container">
        <header>
            <h1>‚ú® Word Reversi ‚ú®</h1>
        </header>

        <main id="main-menu">
            <h2>üéÆ Select Game Mode</h2>
            <button class="menu-btn" onclick="startGame(true, true)">üß† vs Robot (Quiz)</button>
            <button class="menu-btn" onclick="startGame(false, true)">üßë‚Äçü§ù‚Äçüßë 2-Player (Quiz)</button>
            <hr style="border: 0; border-top: 1px solid #ddd; margin: 5px 0;">
            <button class="menu-btn" onclick="startGame(true, false)">ü§ñ vs Robot (Classic)</button>
            <button class="menu-btn" onclick="startGame(false, false)">üßë‚Äçü§ù‚Äçüßë 2-Player (Classic)</button>
        </main>

        <main id="game-screen" class="hidden">
            <div id="score-board">
                <span id="score-black">‚ö´ 2</span>
                <span id="score-white">‚ö™ 2</span>
            </div>
            <div id="status-message">Loading...</div>

            <div id="game-board-container">
                <div id="game-board"></div>
            </div>

            <div id="question-overlay" class="hidden">
                <div id="question-box">
                    <h2 style="color:#6c5ce7; margin-bottom:10px;">Vocabulary</h2>
                    <p id="question-text"></p>
                    <div id="options-container"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // === GAME CONFIGURATION ===
        const BOARD_SIZE = 8;
        let board = [];
        let currentPlayer = 1; // 1=Black, 2=White
        let lastClickedCell = null;
        let isRobotMode = false;
        let isQuizMode = true;
        let isProcessing = false;
        let availableQuizIndices = [];

        // === AUDIO SYSTEM (Web Audio API) ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'correct') { // Ping!
                osc.type = 'sine';
                osc.frequency.setValueAtTime(500, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'error') { // Buzz!
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'flip') { // Click!
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        }

        // === VOCABULARY LIST (Sample) ===
        const vocabularyList = [
            { question: "Opposite of 'Big'?", options: { A: "Small", B: "Huge" }, correct: "A" },
            { question: "Synonym for 'Happy'?", options: { A: "Sad", B: "Joyful" }, correct: "B" },
            { question: "'Run' means...", options: { A: "Move fast", B: "Sleep" }, correct: "A" },
            { question: "Opposite of 'Hot'?", options: { A: "Cold", B: "Warm" }, correct: "A" },
            { question: "Synonym for 'Start'?", options: { A: "Begin", B: "End" }, correct: "A" },
            { question: "Opposite of 'Day'?", options: { A: "Night", B: "Morning" }, correct: "A" },
            { question: "Opposite of 'Up'?", options: { A: "Down", B: "Left" }, correct: "A" },
            { question: "Synonym for 'Quick'?", options: { A: "Slow", B: "Fast" }, correct: "B" },
            { question: "Opposite of 'Rich'?", options: { A: "Poor", B: "Wealthy" }, correct: "A" },
            { question: "Does 'Cat' meow?", options: { A: "Yes", B: "No" }, correct: "A" }
        ];

        // === DOM ELEMENTS ===
        const els = {
            menu: document.getElementById('main-menu'),
            game: document.getElementById('game-screen'),
            board: document.getElementById('game-board'),
            status: document.getElementById('status-message'),
            overlay: document.getElementById('question-overlay'),
            qBox: document.getElementById('question-box'),
            qText: document.getElementById('question-text'),
            opts: document.getElementById('options-container'),
            scoreB: document.getElementById('score-black'),
            scoreW: document.getElementById('score-white')
        };

        const DIRECTIONS = [
            {r:-1,c:0}, {r:1,c:0}, {r:0,c:-1}, {r:0,c:1},
            {r:-1,c:-1}, {r:-1,c:1}, {r:1,c:-1}, {r:1,c:1}
        ];

        // === CORE FUNCTIONS ===
        function startGame(robot, quiz) {
            isRobotMode = robot;
            isQuizMode = quiz;
            isProcessing = false;
            
            // Activate Audio Context
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            els.menu.classList.add('hidden');
            els.game.classList.remove('hidden');
            
            if(isQuizMode) {
                availableQuizIndices = Array.from({length: vocabularyList.length}, (_, i) => i);
            }
            initBoard();
        }

        function returnToMenu() {
            els.menu.classList.remove('hidden');
            els.game.classList.add('hidden');
            currentPlayer = 1;
        }

        function initBoard() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            els.board.innerHTML = '';
            
            // Create Cells
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.onclick = handleCellClick;
                    els.board.appendChild(cell);
                }
            }
            
            // Initial Discs
            board[3][3] = 2; board[3][4] = 1;
            board[4][3] = 1; board[4][4] = 2;
            
            updateVisuals();
            updateStatus();
        }

        function getFlips(r, c, player) {
            if (board[r][c] !== 0) return [];
            const opponent = player === 1 ? 2 : 1;
            const flips = [];

            for (const d of DIRECTIONS) {
                let nr = r + d.r, nc = c + d.c;
                const path = [];
                while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === opponent) {
                    path.push({r: nr, c: nc});
                    nr += d.r; nc += d.c;
                }
                if (path.length > 0 && nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                    flips.push(...path);
                }
            }
            return flips;
        }

        function isValid(r, c, player) {
            return getFlips(r, c, player).length > 0;
        }

        function getAllMoves(player) {
            const moves = [];
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if(isValid(r, c, player)) moves.push({r, c});
                }
            }
            return moves;
        }

        function updateVisuals() {
            const validMoves = getAllMoves(currentPlayer);
            let bCount = 0, wCount = 0;
            
            // Should check if it's human's turn for hints
            const showHints = !isProcessing && !(isRobotMode && currentPlayer === 2);

            Array.from(els.board.children).forEach(cell => {
                const r = parseInt(cell.dataset.r);
                const c = parseInt(cell.dataset.c);
                const val = board[r][c];
                
                cell.className = 'cell'; // Reset
                cell.innerHTML = '';
                
                if (val !== 0) {
                    const disc = document.createElement('div');
                    disc.className = `disc ${val === 1 ? 'black' : 'white'}`;
                    cell.appendChild(disc);
                    val === 1 ? bCount++ : wCount++;
                } else if (showHints && validMoves.some(m => m.r === r && m.c === c)) {
                    cell.classList.add('hint');
                }
            });

            els.scoreB.innerText = `‚ö´ ${bCount}`;
            els.scoreW.innerText = `‚ö™ ${wCount}`;
        }

        function updateStatus() {
            const pName = currentPlayer === 1 ? '‚ö´ Black' : '‚ö™ White';
            const moves = getAllMoves(currentPlayer);
            
            if (moves.length === 0) {
                const oppMoves = getAllMoves(currentPlayer === 1 ? 2 : 1);
                if (oppMoves.length === 0) {
                    // Game Over
                    const b = parseInt(els.scoreB.innerText.split(' ')[1]);
                    const w = parseInt(els.scoreW.innerText.split(' ')[1]);
                    const winMsg = b > w ? 'Black Wins!' : w > b ? 'White Wins!' : 'Draw!';
                    els.status.innerHTML = `üèÜ ${winMsg} <button onclick="returnToMenu()" style="margin-left:10px; padding:2px 8px;">Menu</button>`;
                } else {
                    // Pass
                    els.status.innerText = `üö´ ${pName} Pass!`;
                    setTimeout(() => {
                        currentPlayer = currentPlayer === 1 ? 2 : 1;
                        updateStatus();
                    }, 1500);
                }
                return;
            }

            els.status.innerText = `${pName}'s Turn`;
            
            updateVisuals(); // Update hints
            
            if (isRobotMode && currentPlayer === 2) {
                setTimeout(botMove, 1000);
            }
        }

        function handleCellClick(e) {
            if (isProcessing || !els.overlay.classList.contains('hidden')) return;
            if (isRobotMode && currentPlayer === 2) return;

            const r = parseInt(e.currentTarget.dataset.r);
            const c = parseInt(e.currentTarget.dataset.c);

            if (!isValid(r, c, currentPlayer)) {
                // Optional: Shake animation or sound for invalid
                return;
            }

            lastClickedCell = {r, c};

            if (isQuizMode) {
                startQuiz();
            } else {
                executeMove(true); // Classic mode always succeeds
            }
        }

        // === QUIZ LOGIC ===
        function startQuiz() {
            if (availableQuizIndices.length === 0) {
                availableQuizIndices = Array.from({length: vocabularyList.length}, (_, i) => i);
            }
            const randIdx = Math.floor(Math.random() * availableQuizIndices.length);
            const qIdx = availableQuizIndices[randIdx];
            availableQuizIndices.splice(randIdx, 1);
            
            const q = vocabularyList[qIdx];
            currentQuestion = q;
            
            els.qBox.className = ''; // Remove color classes
            els.qText.innerText = q.question;
            els.opts.innerHTML = '';
            
            Object.keys(q.options).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.innerText = q.options[key];
                btn.onclick = () => handleAnswer(key);
                els.opts.appendChild(btn);
            });
            
            els.overlay.classList.remove('hidden');
        }

        function handleAnswer(ans) {
            const btns = els.opts.querySelectorAll('button');
            btns.forEach(b => b.disabled = true);
            
            const correct = ans === currentQuestion.correct;
            
            if (correct) {
                els.qBox.classList.add('quiz-correct');
                playSound('correct');
            } else {
                els.qBox.classList.add('quiz-error');
                playSound('error');
            }
            
            setTimeout(() => {
                els.overlay.classList.add('hidden');
                executeMove(correct);
            }, 800);
        }

        // === GAME LOGIC ===
        function botMove() {
            const moves = getAllMoves(currentPlayer);
            if (moves.length > 0) {
                const m = moves[Math.floor(Math.random() * moves.length)];
                lastClickedCell = m;
                executeMove(true); // Bot always correct/classic
            }
        }

        async function executeMove(shouldFlip) {
            isProcessing = true;
            const {r, c} = lastClickedCell;
            const opponent = currentPlayer === 1 ? 2 : 1;
            
            // Place disc
            board[r][c] = currentPlayer;
            updateVisuals(); // Show placed disc immediately
            
            // Calculate flips
            const flips = shouldFlip ? getFlips(r, c, currentPlayer) : [];
            
            if (flips.length > 0) {
                // Flip Animation Loop
                for (const f of flips) {
                    await new Promise(res => setTimeout(res, 200)); // Delay between flips
                    const idx = f.r * BOARD_SIZE + f.c;
                    const cell = els.board.children[idx];
                    const disc = cell.querySelector('.disc');
                    if (disc) {
                        disc.classList.add('flipped');
                        playSound('flip');
                        
                        // Wait for half animation to swap color logic visually (optional but good)
                        setTimeout(() => {
                            board[f.r][f.c] = currentPlayer;
                            // We don't call updateVisuals here to avoid re-rendering entire board
                            // Just let the CSS animation finish the visual swap
                            disc.classList.remove('black', 'white');
                            disc.classList.add(currentPlayer === 1 ? 'black' : 'white');
                        }, 250);
                    }
                }
                // Sync internal state fully after animations
                await new Promise(res => setTimeout(res, 300));
                flips.forEach(f => board[f.r][f.c] = currentPlayer);
                updateVisuals();
            }
            
            isProcessing = false;
            currentPlayer = opponent;
            updateStatus();
        }

    </script>
</body>
</html>
